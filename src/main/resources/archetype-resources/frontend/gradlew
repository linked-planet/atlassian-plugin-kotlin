#set($h = '#')
#set($d = '$')
${h}!/bin/sh

${h}
${h} Copyright © 2015-2021 the original authors.
${h}
${h} Licensed under the Apache License, Version 2.0 (the "License");
${h} you may not use this file except in compliance with the License.
${h} You may obtain a copy of the License at
${h}
${h}      https://www.apache.org/licenses/LICENSE-2.0
${h}
${h} Unless required by applicable law or agreed to in writing, software
${h} distributed under the License is distributed on an "AS IS" BASIS,
${h} WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
${h} See the License for the specific language governing permissions and
${h} limitations under the License.
${h}

${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}
${h}
${h}   Gradle start up script for POSIX generated by Gradle.
${h}
${h}   Important for running:
${h}
${h}   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
${h}       noncompliant, but you have some other compliant shell such as ksh or
${h}       bash, then to run this script, type that shell name before the whole
${h}       command line, like:
${h}
${h}           ksh Gradle
${h}
${h}       Busybox and similar reduced shells will NOT work, because this script
${h}       requires all of these POSIX shell features:
${h}         * functions;
${h}         * expansions «${d}var», «${d}{var}», «${d}{var:-default}», «${d}{var+SET}»,
${h}           «${d}{var${h}prefix}», «${d}{var%suffix}», and «${d}( cmd )»;
${h}         * compound commands having a testable exit status, especially «case»;
${h}         * various built-in commands including «command», «set», and «ulimit».
${h}
${h}   Important for patching:
${h}
${h}   (2) This script targets any POSIX shell, so it avoids extensions provided
${h}       by Bash, Ksh, etc; in particular arrays are avoided.
${h}
${h}       The "traditional" practice of packing multiple parameters into a
${h}       space-separated string is a well documented source of bugs and security
${h}       problems, so this is (mostly) avoided, by progressively accumulating
${h}       options in "${d}@", and eventually passing that to Java.
${h}
${h}       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
${h}       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
${h}       see the in-line comments for details.
${h}
${h}       There are tweaks for specific operating systems such as AIX, CygWin,
${h}       Darwin, MinGW, and NonStop.
${h}
${h}   (3) This script is generated from the Groovy template
${h}       https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
${h}       within the Gradle project.
${h}
${h}       You can find Gradle at https://github.com/gradle/gradle/.
${h}
${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}${h}

${h} Attempt to set APP_HOME

${h} Resolve links: ${d}0 may be a link
app_path=${d}0

${h} Need this for daisy-chained symlinks.
while
    APP_HOME=${d}{app_path%"${d}{app_path${h}${h}*/}"}  ${h} leaves a trailing /; empty if no leading path
    [ -h "${d}app_path" ]
do
    ls=${d}( ls -ld "${d}app_path" )
    link=${d}{ls${h}*' -> '}
    case ${d}link in             ${h}(
      /*)   app_path=${d}link ;; ${h}(
      *)    app_path=${d}APP_HOME${d}link ;;
    esac
done

APP_HOME=${d}( cd "${d}{APP_HOME:-./}" && pwd -P ) || exit

APP_NAME="Gradle"
APP_BASE_NAME=${d}{0${h}${h}*/}

${h} Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

${h} Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "${d}*"
} >&2

die () {
    echo
    echo "${d}*"
    echo
    exit 1
} >&2

${h} OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "${d}( uname )" in                ${h}(
  CYGWIN* )         cygwin=true  ;; ${h}(
  Darwin* )         darwin=true  ;; ${h}(
  MSYS* | MINGW* )  msys=true    ;; ${h}(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=${d}APP_HOME/gradle/wrapper/gradle-wrapper.jar


${h} Determine the Java command to use to start the JVM.
if [ -n "${d}JAVA_HOME" ] ; then
    if [ -x "${d}JAVA_HOME/jre/sh/java" ] ; then
        ${h} IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=${d}JAVA_HOME/jre/sh/java
    else
        JAVACMD=${d}JAVA_HOME/bin/java
    fi
    if [ ! -x "${d}JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: ${d}JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

${h} Increase the maximum file descriptors if we can.
if ! "${d}cygwin" && ! "${d}darwin" && ! "${d}nonstop" ; then
    case ${d}MAX_FD in ${h}(
      max*)
        MAX_FD=${d}( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case ${d}MAX_FD in  ${h}(
      '' | soft) :;; ${h}(
      *)
        ulimit -n "${d}MAX_FD" ||
            warn "Could not set maximum file descriptor limit to ${d}MAX_FD"
    esac
fi

${h} Collect all arguments for the java command, stacking in reverse order:
${h}   * args from the command line
${h}   * the main class name
${h}   * -classpath
${h}   * -D...appname settings
${h}   * --module-path (only if needed)
${h}   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

${h} For Cygwin or MSYS, switch paths to Windows format before running java
if "${d}cygwin" || "${d}msys" ; then
    APP_HOME=${d}( cygpath --path --mixed "${d}APP_HOME" )
    CLASSPATH=${d}( cygpath --path --mixed "${d}CLASSPATH" )

    JAVACMD=${d}( cygpath --unix "${d}JAVACMD" )

    ${h} Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case ${d}arg in                                ${h}(
              -*)   false ;;                            ${h} don't mess with options ${h}(
              /?*)  t=${d}{arg${h}/} t=/${d}{t%%/*}              ${h} looks like a POSIX filepath
                    [ -e "${d}t" ] ;;                      ${h}(
              *)    false ;;
            esac
        then
            arg=${d}( cygpath --path --ignore --mixed "${d}arg" )
        fi
        ${h} Roll the args list around exactly as many times as the number of
        ${h} args, so each arg winds up back in the position where it started, but
        ${h} possibly modified.
        ${h}
        ${h} NB: a `for` loop captures its iteration list before it begins, so
        ${h} changing the positional parameters here affects neither the number of
        ${h} iterations, nor the values presented in `arg`.
        shift                   ${h} remove old arg
        set -- "${d}@" "${d}arg"      ${h} push replacement arg
    done
fi

${h} Collect all arguments for the java command;
${h}   * ${d}DEFAULT_JVM_OPTS, ${d}JAVA_OPTS, and ${d}GRADLE_OPTS can contain fragments of
${h}     shell script including quotes and variable substitutions, so put them in
${h}     double quotes to make sure that they get re-expanded; and
${h}   * put everything else in single quotes, so that it's not re-expanded.

set -- \
        "-Dorg.gradle.appname=${d}APP_BASE_NAME" \
        -classpath "${d}CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "${d}@"

${h} Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

${h} Use "xargs" to parse quoted args.
${h}
${h} With -n1 it outputs one arg per line, with the quotes and backslashes removed.
${h}
${h} In Bash we could simply go:
${h}
${h}   readarray ARGS < <( xargs -n1 <<<"${d}var" ) &&
${h}   set -- "${d}{ARGS[@]}" "${d}@"
${h}
${h} but POSIX shell has neither arrays nor command substitution, so instead we
${h} post-process each arg (as a line of input to sed) to backslash-escape any
${h} character that might be a shell metacharacter, then use eval to reverse
${h} that process (while maintaining the separation between arguments), and wrap
${h} the whole thing up as a single "set" statement.
${h}
${h} This will of course break if any of these variables contains a newline or
${h} an unmatched quote.
${h}

eval "set -- ${d}(
        printf '%s\n' "${d}DEFAULT_JVM_OPTS ${d}JAVA_OPTS ${d}GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"${d}@"'

exec "${d}JAVACMD" "${d}@"
